class BaseClass{	func base()	{		println("父类的普通方法")	}	func test()	{		println("父类的被覆盖的方法")	}}class SubClass : BaseClass{	override func test()	{		println("子类的覆盖父类的方法")	}	func sub()	{		println("子类的普通方法")	}}// 下面编译时类型和运行时类型完全一样，因此不存在多态let bc: BaseClass = BaseClass()// 下面两次调用将执行BaseClass的方法bc.base()bc.test()// 下面编译时类型和运行时类型完全一样，因此不存在多态let sc: SubClass = SubClass()// 下面调用将执行从父类继承到的base()方法sc.base()// 下面调用将执行从当前类的test()方法sc.test()// 下面编译时类型和运行时类型不一样，多态发生let ploymophicBc: BaseClass = SubClass()// 下面调用将执行从父类继承到的base()方法ploymophicBc.base()// 下面调用将执行从当前类的test()方法ploymophicBc.test()// 因为ploymophicBc的编译类型是BaseClass，// BaseClass类没有提供sub方法,所以下面代码编译时会出现错误。//ploymophicBc.sub()